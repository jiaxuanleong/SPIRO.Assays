# process_rootgrowth_data.R - 
#
#   takes data generated by cleanup_rootgrowth_data.R and estimates per-group root growth rates.
# 
library(readr)
library(doParallel)
library(foreach)
library(doRNG)
library(ggplot2)

# number of repetitions for the permutation test
tries <- 5000

# ensure consistent results
set.seed(924)

# permutation testing function
# returns TRUE (1) if permuted set yields lower or same p-value
permute <- function(ds, base.p) {
  perm_uids <- unique(ds$UID)
  order <- sample(perm_uids)
  newds <- ds
  k <- 0

  for (j in order) {
    k <- k + 1
    newds$Group[which(ds$UID == perm_uids[k])] <- ds$Group[which(ds$UID == j)][1]
  }

  mod.1 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T), data=newds)
  mod.2 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T) * Group, data=newds)
  mod.aov <- anova(mod.1, mod.2)

  # check if p-value of ANOVA model comparison is lower than or equal to the original
  return(mod.aov$`Pr(>F)`[2] <= base.p)
}

# there is no support for directory picker under non-windows platforms
if (.Platform$OS.type == 'unix') {
  dir <- readline(prompt = "Enter directory: ")
} else {
  dir <- choose.dir(getwd(), "Choose folder to process")
}

resultsdir <- paste0(dir, '/Results')
outdir <- paste0(resultsdir, '/Root growth assay')

# set up output dir
if (dir.exists(paste0(outdir, '/Analysis output'))) {
  runs <- list.dirs(paste0(outdir, '/Analysis output'), full.names=F, recursive=F)
  run_number <- length(runs) + 1
  while (file.exists(paste0(outdir, '/Analysis output/', run_number))) {
    run_number <- run_number + 1
  }
} else {
  dir.create(paste0(outdir, '/Analysis output'), recursive=T)
  run_number <- 1
}

rundir <- paste0(outdir, '/Analysis output/', run_number)
dir.create(rundir, showWarnings=F)

if (file.exists(paste0(outdir, "/rootgrowth.postQC.tsv"))) {
  data <- read.table(paste0(outdir, "/rootgrowth.postQC.tsv"), header=T, stringsAsFactors=F)
} else {
  stop("rootgrowth.postQC.tsv not found in specified directory. Did you run cleanup_rootgrowth_data.R?\n")
}

data <- read_tsv(paste0(outdir, '/rootgrowth.postQC.tsv'),
                 col_types=c(UID=col_character(), Group=col_character(), ElapsedHours=col_skip(),
                             RelativeElapsedHours=col_double(), PrimaryRootLength=col_double(),
                             Date=col_skip()))

# copy postQC input file to rundir for reference
file.copy(paste0(outdir, "/rootgrowth.postQC.tsv"), rundir)

# loop to ask the user to choose the control group
groups <- as.character(unique(data$Group))
ngroups <- length(groups)

if (ngroups > 1) {
  ctrl <- 0
  while (ctrl<1) {
    cat("More than one group detected in dataset. Please indicate which group is the control.\n\n")
    i <- 0
    for (group in groups) {
      i <- i + 1
      cat(paste0("[", i, "] ", group, "\n"))
    }
    cat("\n")
    ctrl <- as.numeric(readline(prompt = "Enter the number of the control group: "))
    if (is.na(ctrl)) {
      ctrl <- 0
    }
  }
  ctrlgroup <- groups[ctrl]
  expgroups <- groups[!groups %in% ctrlgroup]
} else 

# plot all data points with polynomial fit overlaid
p <- NULL
p <- ggplot(data, aes(x=RelativeElapsedHours, y=PrimaryRootLength, color=Group, group=Group)) + 
  geom_point(size=.3, alpha=.5) +
  geom_smooth(method="lm", formula= y ~ poly(x, 2, raw=T)) + 
  labs(x="Time since root emergence (h)", 
       y="Primary root length (cm)", 
       title="Primary root growth per group")
suppressWarnings(ggsave(p, filename=paste0(rundir, "/rootgrowth-allgroups.pdf"), width=25, height=15, units="cm"))

# if we have more than one group, perform pairwise comparisons against control
stats <- NULL
if (ngroups > 1) {
  # fire up the cluster
  num_cores <- max(1, detectCores() - 1)
  cl <- makeCluster(num_cores)
  registerDoParallel(cl)
  
  if (num_cores > 1) {
    core_plural <- 'threads'
  } else {
    core_plural <- 'thread'
  }

  cat(paste0("Performing permutation testing of root growth models, using ", 
             length(cl), ' ', core_plural, ". This may take a little while...\n"))
  
  exactpvals <- pvals <- rss1s <- rss2s <- r2s <- NULL

  for (group in expgroups) {
    cat("Comparing", group, "against", ctrlgroup, "--- ")
    ds <- data[data$Group %in% c(group, ctrlgroup),]
    mod1 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T), data=ds)
    mod2 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T) * Group, data=ds)
    a <- anova(mod1, mod2)
    rss1s <- c(rss1s, a$RSS[1])
    rss2s <- c(rss2s, a$RSS[2])
    pvals <- c(pvals, a$`Pr(>F)`[2])

    # fit baseline model on non-permuted data, for comparison
    basemod.1 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T), data=ds)
    basemod.2 <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T) * Group, data=ds)
    basemod.aov <- anova(basemod.1, basemod.2)
    base.p <- basemod.aov$`Pr(>F)`[2]

    # use %dorng% instead of %dopar% to ensure consistent results
    better <- foreach(i=seq(tries), .combine=sum, .multicombine=T) %dorng%
      permute(ds, base.p)

    p <- ggplot(ds, aes(x=RelativeElapsedHours, y=PrimaryRootLength, color=Group, group=Group)) + 
      geom_point(size=.3, alpha=.5) + 
      geom_smooth(method="lm", formula = y ~ poly(x, 2, raw=T)) +
      labs(x="Relative time (h)",
           y="Primary root length (cm)",
           title=paste0("Model fit for group ", group, " compared to control"))
    suppressWarnings(ggsave(p, filename = paste0(rundir, "/rootgrowth-", group, ".pdf"), width=25, height=15, units="cm"))
    
    exactpvals <- c(exactpvals, better/tries)
    cat("the exact p-value is", better/tries, "\n")
  }

  stopCluster(cl)
  stats <- data.frame(Exp.Group = expgroups, Ctrl.Group = ctrlgroup, Exact.p.value = exactpvals, Model1.RSS = rss1s, Model2.RSS = rss2s)
  cat(paste0("Writing statistics to ", rundir, "/modelfits.tsv.\n"))
  write.table(stats, file=paste0(rundir, "/modelfits.tsv"), sep='\t', row.names = F)
  
  b0s <- b1s <- b2s <- NULL
  for (group in groups) {
    mod <- lm(PrimaryRootLength ~ poly(RelativeElapsedHours, 2, raw=T), data=data[data$Group == group,])
    c <- coef(mod)
    b0s <- c(b0s, c[1])
    b1s <- c(b1s, c[2])
    b2s <- c(b2s, c[3])
  }
  
  coefs <- data.frame(Group = groups, b0 = b0s, b1 = b1s, b2 = b2s)
  cat(paste0("Writing model coefficients to ", rundir, "/coefficients.tsv.\n"))
  write.table(coefs, file=paste0(rundir, "/coefficients.tsv"), sep='\t', row.names = F)
} else {
  # if we only have one group
}
